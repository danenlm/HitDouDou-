2018/2/11
准备：
 1.犀牛书
 2.微信公众号：前端大全
 3.上一届的笔记：打印，预习
正课
1.string
  什么是：由多个字符组成的字符数组
  VS数组：相同：1.下标 2.长度：.length 3.for循环遍历 
		4.选取：.slice(starti,endi+1)
          不同：类型不同，API不通用！
  API：应用程序编程接口（预定义函数）
   注意：所有字符串API都无权修改原字符串，只能返回返回新字符串
   1.大小写转换：
     str.toUpperCase()   //转大写
     str.toLowerCase()   //转小写
     何时用：不区分大小写时使用
   2.获取指定位置的字符
     str.charAt(i) 等同于str[i]
   3.获取指定位置的字符的unicode号
     str.charCodeAt(i) 返回的是Unicode编号
     反向将Unicode码转回字
     String.fromCharCode();
   4.选取子字符串
     1.str.slice(starti,endi+1)
     2.str.substring(starti,endi+1) 唯独不支持负数参数
     3.str.substr(starti,n) 从starti开始，选n个
   5.查找关键词（4种）
     1.查找一个固定的关键词出现的位置
       str.indexOf("关键词",fromi) fromi可以省略，默认从0开始
       只能查找固定关键词，只要关键词发生变化，就找不到了
       如果找不到，返回-1
     2.查找一个关键词最后一次出现的位置
       str.lastIndexOf("关键词")
     3.用正则判断是否包含关键词：
       var i=str.search(/正则表达式/);
       表示：查找str中的第一个关键词，如果找到，返回关键词的位置，如果没找到，返回-1
2.正则表达式（regular Expression）
  什么是：规定字符串字符出现规律的规则
  何时使用：2个时候
      1.按规则模糊查找多种关键词
      2.验证字符串格式
  如何使用：
      1.关键词原文，就是最简单的正则
      2.字符集:
        什么是：规定字符串中一位字符上备选字符列表的集合
	何时：只要关键词中，有一位字符上由多种备选字时
	如何：[备选字列表]
	  简写：如果备选字列表中的字符是连续的，可用-省略中间字符
	  一个汉字[\u4e00-\u9fa5]
	反选：[^备选字列表]:除了备选字列表
      3.预定义字符集
        含义：对常用字符集的更简化写法
	     \d: 一位数字=> [0-9]
	     \w：一位字母，数字或下划线[A-Za-z0-9_]
	     \s：一位空字符：空格，Tab...
	     . ：通配符 可代表一切字符
        问题：无法灵活规定字符出现的数量
        解决：量词
      4.量词
        什么是：规定一位字符出现次数的规则
	何时：只要规定一位字符出现的次数
	如何：字符集量词，默认仅能修饰相邻的字符集
	包括：2类
	     1.有明确数量边界的：{countstart,countend}
	       countend可以不要表示，从countstart开始全要，逗号必须留下
	       countend和逗号都不要，表示只能选择countstart
	     2.没有明确边界的：
	       1.可有可无，数量不限：*
	       2.可有可无，最多一个：?
	       3.至少一个，多了不限：+
      5.选择和分组
        选择：或  多个规则匹配其一即可
	  规则1|规则2|...
	分组：()  将多个规则，包裹为一组
	何时：只要希望一个量词同时修饰多个字符集时，都要先将字符集用()包裹为一组，再用量词修饰整个分组
      6.匹配位置
        ^ 字符串的开头
	$ 字符串的结尾
	何时：仅匹配字符串的开头和结尾时使用
	比如：开头的空字符 ^\s+
	      结尾的空字符 \s+$
	      开头和结尾的空字符 ^\s+|\s+$
	\b 单词边界：开始 结尾 空字符 标点
	比如：\b单词\b 选择单词
	      \b[a-z]  选择单词首字母
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2018/2/12
正课：
1.String
  1.查找：4种
    1.查找一个固定的关键词的位置
      str.indexOf("关键词",fromi)
      str.lastIndexOf("关键词")
      问题：只能查找一个固定的关键词，如果发生变化，就找不到
      解决：正则
    2.用正则表达式判断是否包含敏感词
      var i=str.search(/正则表达式/)
      如果i不是-1，说明包含
      如果i是-1，说明不包含
      问题：正则表达式天生不区分大小写
      解决：在第二个/后加后缀i，表示ignore
      问题：只能找一个，且只能获得位置，不能获得内容
    3.str.match 2种用法
      1.查找第一个关键词的内容和位置
        var arr=str.match(/正则/i)
	返回值：找到，返回arr:[0:关键词,index:位置]
	        找不到，返回NULL
      2.查找所有关键词的内容
        var arr=str.match(/正则/ig)  g=>global(全部)
	返回值：找到，返回arr:["关键词 1","关键词 2"]
     问题：只能查找内容，无法查找位置
    4.即找每个关键词内容，又找位置
      RegExp里面API第二种
  2.替换：2种
    1.简单替换：将所有敏感词替换为统一内容 有2种
      1.关键词固定
       str.replace("关键词","替换值");
       强调：无权直接替换原字符串，只能返回新字符串，必须用变量接住替换后的新值
       问题：只能替换一个关键词
      2.关键词变化
       str.replace(/正则/ig,"替换值");
    2.高级替换：根据不同的敏感词，动态选择替换不同的值
      str.replace(/正则/ig,function(kw){
        //kw会自动接收到，当前找到的关键词
	return 根据kw的不同，返回不同的值
      });
    衍生：删除关键词，将关键词替换为""
  3.切割
    1.简单切割：按照固定的分割将字符串切割为多段子字符串
     str.split("切割符")
     强调：在结果数组中，不包含切割符
     固定用法：将字符串打散为字符数组
     str.split("")
    2.复杂切割：切割符不确定的情况
     str.split(/正则/)
2.RegExp
  1.什么是：专门保存一条正则表达式的对象，并提供了用正则表达式执行验证和查找的API
  2.何时：只要在程序中保存一条正则表达式，都要用正则表达式对象
  3.如何：有2种
    1.直接量：var reg=/正则/ig 
      何时：只要正则表达式固定不变就使用1
    2.用new： var reg=new RegExp("正则表达式","ig")
      何时：如果正则表达式需要用程序动态生成就使用2
  4.API:有2个
    1.验证格式：reg.test(str)
      检查字符串str的格式，是否符合正则reg的格式
      问题：默认，只要字符串中部分规则和正则相符，就返回true，不要求完全匹配
      解决：前加^后加$,意味从头到尾必须完整匹配
    2.补全第4种查找方式：既查找关键词，又查找位置
      reg.exec(str)
      在str中查找下一个符合reg要求的关键处的内容和位置
      找到：返回arr[0.关键词 index.位置]
      未找到：返回NULL
3.Math
  1.什么是：专门封装数学计算的常量和API的对象
  2.何时：只要使用数学计算的常量或进行数学计算时
  3.如何：强调：不能new！所有属性和API都用大写的Math直接调用
  4.API
    1.取整：有3种
      1.上取整：Math.ceil(num)
      2.下取整：
	Math.floor(num) 只能处理数字
	parsrInt(str)   可以去掉数字后的非数字字符 优先使用   
      3.四舍五入取整：
        Math.round(num) 优：返回数字，可直接做计算
	                缺：只能取整，不能规定小数位数
        num.toFixed(d)  优：返回字符串
	                缺：可灵活规定小数位数
    2.乘方和开方
      Math.pow(底数，幂)
      Math.sqrt(num)
    3.最大值，最小值
      Math.max(值1,值2,...)
      Math.min(值1,值2,...)
      问题：不支持从数组中获得最大值和最小值
      解决：Math.max(...arr)
       ...可将数组打散为单个值，再传递给函数
    4.三角函数
      Math.atan(对边长/临边长)
      问题：无法区分象限
      解决：今后算角度一律用atan2
      Math.atan2(对边长,临边长)
    5.随机数
      1.Math.random() 在0-1之间生成随机小数
      2.在min~max之间取随机：
        parseInt(Math.random()*((max-min+1)+min)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2018/2/22
正课：
1.Date
 什么是：存储一个时间，并提供操作时间的API
 何时：只要在程序中存储或计算时间都使用日期对象
 如何：创建有4种
   1.创建日期对象，并自动获得当前系统时间
     var now=new Date();
     now.getTime()  获取毫秒数
     强调：因为JS是在客户端执行，所以new Date()只能获得客户端系统时间
   2.创建日期对象，并保存自定义时间
     var date=new Date("yyyy/mm/dd hh:mm:ss");
   3.复制一个日期对象（因为日期的计算会改变原始日期，复制一个日期保护原日期）
     var date2=new Date(date1);
   4.将毫秒数，转化为当地时间
     var date=new Date(ms);
     何时：将数据库中保存的毫秒数，转化为人能看懂的日期对象，且换算成当地时间
     本质：计算机中日期对象中保存的不是字符串，而是一个毫秒数。1970年1月1日0点0秒（0时区国际标准时间）至今的毫秒数
      字符串的缺点：1.受时区影响； 2.不便于计算
      毫秒数的优点：1.不受时区影响； 2.便于计算
              缺点：人看不懂
      所以数据库中存储的都是毫秒数
 API:3句话
  1.8个单位
    FullYear() Month() Date() Day(一周的一天)
    Hours() Minutes() Seconds() Milliseconds()
  2.每个单位上都有一对get/set方法
    其中：getxxx() 专门获取单位的值
          setxxx(num) 专门设置单位的值
	强调：setxxx(num) 可自动计算时间进制
	      day没有set，因为星期几不能随便改
  3.取值范围
    Month：0~11 计算机中的月份都比现实中小1
    Date：0~31
    Day：0~6 0就是星期日
    Hours：0~23
    Minutes/Seconds：0~59
  4.计算有2种
    1.两日期对象可相减：结果是毫秒差
    2.对任意单位做加减：3步
      1.取值：
      2.计算：
      3.set回去：
      强调：setxxx()直接修改原日期对象
      如果想同时保存计算前后的两个日期对象，应该在计算之前复制原日期对象，再计算
      简写：date.setxxx(date.getxxx()+n);
  5.格式化
    .toString() 转为当地时间的完整格式
    .toLocaleString() 转为当地时间的简化格式
    .toLocaleDateString() 转为当地时间的简化格式，仅保留日期
    .toLocaleTimeString() 转为当地时间的简化格式，仅保留时间
    .toGMTString() 转为国际标准时间（0时区）
2.Error
  什么是：保存错误信息的对象
  如何：
    创建：在发生错误时，自动创建
    包括：错误的类型和错误的原因和出错的位置
  问题：所有程序，一旦发生错误，就会强行退出
  解决：
     错误处理：即使发生错误，也保证程序不中断退出的一种机制
     何时：几乎所有的程序，只要可能发生错误，都要提前进行错误处理
     如何：
       try{
	 可能发生错误的正确代码
       }catch(err){
	 只有发生错误时，才执行的错误处理代码
	 包括：提示用户，保存数据，记录日志
       }
     问题：1.被动的接受错误，无法精确提示用户
	   2.try catch 比正常执行效率低
     解决：尽量提前预知错误原因，用if else 代替 try catch
     笔试题：js中错误的类型有几种：
         答：6种：1.ReferenceError 引用错误：要用的变量未找到
		  2.SyntaxError 语法错误
		  3.TypeError 类型错误：错误的使用了类型
		  4.RangeError 范围错误：特指参数超范围
		  5.URIError
		  6.EvalError
     抛出自定义错误：throw new Error("自定义错误消息")   
     何时：协作程序中用的很多，只要函数的作者，向函数的调用者抛出错误，说明错误使用了函数 
3.Function
  什么是：内存中保存一段代码段的对象
  何时：当程序中，有一项任务可能被反复使用时，都要将任务的代码段，先保存在函数对象中，在发放调用
  为什么：重复使用
  如何：
   创建有3种：
     1.声明：
       function 函数名(参数列表){
	  代码片段
	  return 返回值
       }
       问题：被声明提前
       解决：用赋值方式创建函数对象
     2.直接量赋值：
       var 函数名=function(参数列表){
	  代码片段
	  return 返回值
       }
       优点：不会被声明提前
       揭示了：函数名，其实也是一个普通的变量
               函数其实是一个对象
	       函数名变量通过地址引用函数对象
     3.用new
       var fun=new Function("a","b"..."函数体;return 返回值");
  重载(overload)
    什么是：相同函数名，不同参数列表的多个函数，在调用时可根据传入的参数不同，自动选择对应的函数
    为什么：减少API的数量，减轻调用者的负担
    何时：如果一件事，根据传入的参数不同，执行不同的操作时
    如何：问题：JS不支持重载
          为什么：JS不允许多个同名函数同时存在
	  解决：用arguments对，变通实现
	  arguments是每个函数中，自动创建的接收所有传入函数的参数的对象
	  arguments是类数组对象：长得像数组的对象
	   vs 数组：相同：1、下标 2、length 3、for循环
	            不同：类型不同，API不通用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2018/2/23
正课：
1.垃圾回收(GC)：
 什么是：JS引擎会自动检测不再使用的对象，并自动释放其内容看空间
 为什么：内存容量是极其有限的
 何时：只要引擎检测到一个对象不再被任何变量使用，就会自动释放该对象的内容空间
 垃圾回收器：专门检测并回收垃圾对象的小程序
 如何：
   1.垃圾回收器伴随主程序执行而并行执行
   2.垃圾回收器会记录每个对象被几个变量引用着
   3.只要垃圾回收器发现一个对象不再被任何变量引用，自动回收
 强烈建议：如果一个对象不再被使用，应赋值NULL
2.function
 1.匿名函数
  什么是：定义时未指定函数名的函数
  何时：只要一个函数只用一次，不会重复使用时
  为什么：节约内存
  如何：2种
    1.回调函数：2种
      arr.sort(function(a,b){a-b})
      str.replace(reg,function(kw){return 替换值})
    2.匿名函数自调
      什么是：临时创建一个匿名函数后，立刻调用自己
      为什么：避免使用全局变量，造成全局污染
      何时：所有功能代码都要放在匿名函数自调中
      如何：(function(参数列表){
	函数体;
	功能体...
      })()
 2.作用域与作用域链
   什么是：一个变量的使用范围
   为什么：为了避免函数内外的变量间互相干扰
   包括：2种
     1.全局作用域：保存着所有全部变量/函数
     2.函数作用域：保存着函数内的局部变量
   变量的使用顺序：先用局部变量，局部没有，才去全局找
   函数的生命周期：
     1.程序执行前：
	1.创建一个数组（执行环境栈ECS）用于记录正在执行的函数
	2.浏览器本身也是一个程序，执行环境栈中默认首先记录的是浏览器的主程序main()
	3.main()函数执行时，会创建全局作用域对象(window)，保存所有浏览器内置的对象/方法
     2.函数定义时：
	1.在全局创建函数名变量
	2.在window之外创建函数对象保存函数定义
	3.函数名通过地址引用函数对象
	4.函数对象使用scope属性指回自己来自的作用域
     3.函数调用时：
        1.先在ECS中添加本次被调用的记录
	2.为本次函数调用创建专门的函数作用域对象（AO）
	3.在函数作用域对象中保存本次函数调用所需的所有局部变量
	4.函数作用域对象的parent属性指向函数来自的父级作用域对象
	变量的使用顺序：就近 （先用局部，如果局部没有才去全局window找）
     4.函数调用后：
	本次函数调用的记录从ECS中出栈
	  导致函数作用域对象释放
	    导致局部变量一同释放
	      所以局部变量不可重用
   作用域链：由多级作用域逐级引用形成的链式结构
	保存了：所有的变量
	控制了：变量的使用顺序：先局部，后全局
 3.闭包（closure）
   什么是：既重用变量，又保护变量不被篡改的一种机制
   为什么：
     全局变量：优：可重用；  缺：随处可用，易被篡改
     局部变量：缺：不可重用  优：仅函数内可用，不会被篡改
   何时：既重用变量，又保护变量不被篡改的时候
   如何：3步：判断闭包的三个特点
	1.用外层函数包裹受保护的变量和内层函数
	2.外层函数将内层函数返回到外部：3种途径
	  1.用return
	  2.直接给全局变量赋值
	  3.将内层函数包裹在数组或对象中返回
	3.使用者调用外层函数，获得内层函数的对象
   形成闭包的原因：外层函数函数作用域对象（AO）无法释放
   笔试：2步
       1.找受保护的变量：外层函数的局部变量
       2.找外层函数共返回哪些内层函数：一次外层函数调用，返回的多个内层函数，共用一个AO
   闭包的缺点：占用更多内存空间存（外层函数的AO）
   解决：一旦闭包不再使用，应立即释放闭包结构
3.OOP（面向对象编程）
  什么是：程序中，都是用对象来描述现实中一个具体事物的属性和功能
  为什么：为了便于大量数据和功能的使用和维护
  何时：今后几乎所有的程序，都采用面向对象的方式
  如何：3大特点：封装 继承 多态
   1.封装：
    什么是：创建一个对象，集中保存一个事物的属性和功能
    为什么：便于查找和维护
    何时：只要使用面向对象编程，都要先创建对象
    如何：事物的属性会变成对象的属性
          事物的功能会变成对象的方法
	  属性和方法统称为对象的成员
     3种方式
     1.对象直接量：
       var obj={
	属性名:值,
	属性名:值,
	方法名:function(){
	  ......
	},
	方法名:function(){
	  ......
	}
       }
       访问对象的成员：
         访问对象的属性：对象名.属性名
         访问对象的方法：对象名.方法名()
       问题：对象自己的方法要使用自己的属性
       错误：在方法中直接使用属性名
        为什么：默认，没有加任何前缀的普通变量，只能在作用域链中查找，无权进入任何对象查找
        解决：在方法前加对象名.  
	  但是还是有问题，如果对象名改变会容易忘记改变
	  解决：将对象名改成this，this会自动获得调用方法的.前的对象名
     2.用new创建
      var obj=new Object();
      obj.属性名=值;
      obj.方法名=function(){
	... this.属性名 ...
      }
      本质：JS中的一切对象底层都是关联数组
       vs 关联数组
        相同：1.可用["下标"],也可用.下标方式访问成员  
	        如何选择：
		  1.如果属性名是固定的，首选.
		  2.如果属性名是动态获得的，应用[]
	      2.随时可在任意位置添加新成员
	      3.访问不存在的成员不会报错，返回undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2018/2/24
正课
1.OOP（面向对象编程）
 1.封装：3种
  1.对象直接量
  2.new object
  问题：以上两种都只能创建一个对象，如果反复创建多个对象，代码会很冗余
  解决：用构造函数反复创建多个结构功能相同的对象
  3.构造函数(constructor)
   什么是：描述一类对象统一结构的函数
   何时：只要反复创建相同结构的多个对象时
   为什么：代码重用
   如何：
     定义构造函数：
      function 类型名(属性参数,...){
	this.属性名=属性参数;
	...=...;
	this.方法名=function(){
	  ...this.属性名...
	}
      }
     用构造函数创建对象：
      var obj=new 类型名(属性值,...)
      new:4件事
       1.创建一个空对象
       2.让子对象自动继承构造函数的原型对象
       3.调用构造函数
         1.this->new
	 2.this.属性名=值：通过强行赋值的方式为对象添加新属性，并保存属性值
       4.返回新对象的地址，保存在变量中
   问题：每个对象都有一个重复的相同的方法定义，浪费内存
   解决：继承
 2.继承：
  什么是：父对象的成员，子对象无需重复创建，即可直接使用
  为什么：代码重用，节约内存
  何时：只要多个子对象，拥有相同的属性值和方法时
  如何：通过原型对象
   什么是原型对象：集中保存子对象共有成员的父对象
   如何：
     创建：不用创建
       定义构造函数时，自动附赠一个原型对象（prototype）
       创建子对象时：new的第二步，让子对象自动继承构造函数的原型对象
     添加共有成员：
       构造函数中不再包含共有方法的定义
       所有共有的方法都应添加到构造函数的原型对象中
        构造函数.prototype.方法名=function(){
		...this.属性名...
	}
   自有属性和共有属性
     自有属性：保存在子对象本地，归子对象独有的属性
     共有属性：保存在原型对象中，所有子对象共有的属性
      获取属性值：子对象.属性名 ————相同
      修改属性值：自有属性只能用子对象修改
	         共有属性只能用原型对象修改
   内置类型的原型对象
    笔试：ES中内置类型/对象：11个
     String Number Boolean ————包装类型
     Array Date RegExp Math
     Error
     Function Object
     Global(在浏览器被window代替)
     浏览器自带两个引擎：内容排版引擎（HTML，CSS），脚本解释引擎（JS）
     本质：所有能new的，都是构造函数，而所有的API都保存在构造函数的原型对象中
     问题：旧浏览器无法使用新的API
     解决：让旧浏览器也支持新的API
      如何：向该类型的原型对象中添加自定义的API
      开发时：MDN 类型名.prototype.函数名=>Polyfill
     笔试：对包装类型的理解
      什么是：专门保存一个原始类型的值，并提供操作原始类型值的API
      为什么：原始类型的值不具备任何功能
      何时：只要试图对原始类型的值调用API时，都会自动使用该原始类型对应的包装类型对象
      如何
       创建：不用自己创建
        当试图对原始类型的值调用API时，自动创建对应的包装类型对象
      问题：包装类型的API，也有兼容性问题
      解决：同内置类型的API解决方法一样
   原型链（prototype chain）
    什么是：由多级父对象逐级继承，形成的链式结构
     包含了：所有对象的属性和方法
     控制着：属性和方法的使用顺序，以及共享范围
    笔试：判断一个对象是不是数组类型，有几种方法
     问题：typeof只能区分原始类型和function，无法进一步细致区分引用类型对象的类型
     答：1.判断原型对象
          var bool=Array.prototype.isPrototypeOf(obj)
	  判断Array.prototype是不是obj的父级原型对象
	 2.判断构造函数
	  obj.constructor===Array
	  用obj instanceof Array 代替 
	 前两种问题：不仅检查直接父级，且检查整个原型链
	 3.判断每个对象内部的隐藏属性class
	  class属性在创建对象时保存对象的类型，不随继承关系改变而改变
	  如何：唯一办法：Object.prototype.toString()
	  问题：多数父对象都重写了toString方法，将顶级的toString覆盖，无法直接调用
	  解决：call 让任何一个对象抢到任何一个想调用的函数执行
	   要调用的函数.call(obj)
	 4.用Array.isArray ES5特有的
 3.多态
  什么是：同一个函数，在不同情况下表现出不同的状态
  包括：2种
   1.重载
   2.重写
     什么是：子对象中定义和父对象中的API同名的成员
     为什么：子对象觉得父对象中的成员不好用
     何时：只要子对象觉得父对象中的成员不好用，就可以在子对象本地重写父对象成员
     如何：只要在子对象本地定义和父对象中同名的API
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2018/2/26
1.OOP
 静态方法：不需要创建该类型的子对象，任何对象都可使用的方法
   为什么：有些方法不确定使用他的对象的类型，所以不能放在原对象内部
   何时：不确定将来调用该函数的对象类型时
   如何：添加到构造函数对象上的方法都是静态方法，可通过构造函数.静态方法方式直接调用
   比如：Array.isArray(fun)
   比如：Array.isArray(date)
   比如：Array.isArray(obj)
 自定义继承：
  1.仅修改一个对象的父对象
   //child.__proto__=father  不稳定
   可用Object.setPrototypeOf(child,father)代替
  2.修改所有子对象的父对象
   构造函数.prototype=father
   强调：在创建子对象之前更换
  3.两种类型间的继承
   何时：如果发祥多个类型之间拥有部分相同的属性结构和方法定义时
   如何：2大步
    1.定义抽象父类型（不具体存在）：2件事
     1.构造函数中定义相同的部分属性
     2.在原型对象中定义相同的方法
    2.让子类型继承父类型：2件事
     1.让子类型构造函数借用父类型构造函数
      问题：如何借用
       错误：直接调用父类型构造函数
        结果：父类型构造函数中的属性，泄露到全局
	为什么：一个函数，不用new也不用.调用，this默认都指window
	正确：今后只要函数中的this不是想要的可用call随意更换为想要的对象
	      函数.call(正确的对象,其他参数值)
     2.让子类型原型对象继承父类型原型对象
2.ES5
 1.严格模式
  什么是：比普通的JS运行机制要求更严格的运行模式
  为什么：解决JS中部分广受诟病的缺陷
  何时：几乎所有代码都要运行在严格模式下
  如何：2种
   1.新项目：在所有js文件/script标签的顶部添加："use strict"
   2.旧项目升级：逐个函数向严格模式迁移
    如何：在函数定义内的顶部添加："use strict"
  要求：
    1.禁止给未声明的变量赋值
     针对缺陷：给未声明的变量赋值，会自动在全局创建该变量，造成内存泄漏
     禁止后：避免了因为全局变量造成的内存泄漏
    2.将静默失败升级为错误
     什么是静默失败：运行既不成功，又不报错
    3.所有普通函数调用和匿名函数中的this不再默认指向window,而是undefined
     避免内存泄漏
    4.不再推荐使用arguments.callee
     什么是arguments.callee：可在函数调动时，自动获得函数本身
     其实是禁用递归，因为递归效率极低，重复量太大
     解决：几乎所有递归，都可以用循环代替
 2.保护对象：2个层面
  1.保护属性
   为什么：普通js中对象的属性值可以是任何值，可以随意修改
   如何保护：
    ES5将对象的属性分为2大类
     1.命名属性：可用.直接访问到的属性
     2.内部属性：不能用.直接访问到的属性
       __proto__,constructor,class 都是内部属性，无法访问，不用保护
     如何保护命名属性：
      ES5将命名属性又分为2大类
       1.数据属性：直接保存属性值的属性
        如何保护数据属性：4大特性
	 每个数据属性都又包含4个特性
	  value：值 //实际存储属性值
	  writable:bool //控制当前属性是否可修改
	  enumerable:bool //控制当前属性能否被for in遍历
	  configurable:bool //能否修改其他2种属性
			    //控制能否被删除
	  强调：configurable一旦改为false，不可逆，所以一般都和其他2种属性一起用，双保险
	如何获取属性的4个特性
	 Object.getOwnPropertyDescriptor(obj,"属性名")
	修改属性的4个特性
	 Object.defineProperty(obj,"属性",{
		4大特性：值
	 })
	 问题：一次只能修改修改一个属性的4大特性
	 解决：
	  Object.defineProperties(obj,{
		属性名:{
		  特性:值,
		  特性:值,
		  特性:值
		},
		属性名:{
		  特性:值,
		  特性:值,
		  特性:值
		}
	  })
	数据属性的问题：无法用自定义规则保护属性
	解决：用访问器属性保护数据属性
       2.访问器属性：不实际存储属性值，仅提供对其他数据属性的保护
        如何定义：不能用直接量定义，只能用defineProperty/defineProperties方法添加
	  Object.defineProperty(obj,"访问器属性名",{
		//4大特性
		get:function(){return this.数据属性名},
		set:function(val){
		  if(val符合要求){
			this.数据属性=val;
		  }else{
			throw new Error("错误提示")
		  }
		}
		enumerable:bool
		configurable:bool
	 })
	如何使用访问器属性
	 不用自己调用get和set
	 访问器属性的用法和普通数据属性完全一样
	  原理：当试图获取属性值时，自动调用get，当试图修改时，自动调用set，判定合格后自动调用get赋值
	问题：如果用普通的数据属性保存访问器属性要保护的值，则可能绕过访问器属性，修改被保护的值
	解决：将受保护的属性值，闭包
  2.保护对象结构
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2018/2/27
1.ES5
 1.保护对象
  1. 保护属性
   1.命名属性
    1.数据属性：4大特性：value writable enumerable configurable
    2.访问器属性：4大特性：get() set(val) enumerable configurable
     构造函数中定义保护
   2.内部属性
  2.保护结构:3个层次
   1.防扩展：禁止向对象中添加新属性
    Object.preventExtensions(obj)
    原理：每个对象内，都有一个内部的隐藏属性：extensible:true（可扩展的）
          preventExtensions将extensible改为false
   2.密封：防扩展的同时，进一步禁止删除现有属性
    Object.seal(obj)
    原理：1.将extensible改为false
	  2.自动将所有属性的configurable改为false
   3.冻结：在密封的同时，禁止修改一切属性值
    Object.freeze(obj)
    原理：1.将extensible改为false
	  2.自动将所有属性的configurable改为false
	  3.自动将所有属性的writable改为false
 2.Object.create()
  什么是：创建一个新对象，继承现有的一个指定父对象，同时还可为新对象添加自有属性
  何时：如果没有构造函数，只有父对象，也想创建子对象时
  如何：1.简单：仅继承：var child=Object.create(father)
	2.高级：既继承，又扩展自有属性
	 var child=Object.create(father，{
		//defineproperties的格式一样

	 })
 3.call(),apply(),bind()
  共同点：都是替换函数中不想要的this为想要的对象
  何时：只要一个函数调用时，其中的this不是想要的时候
  如何：
   1.call/apply
     强行调用指定函数，并临时替换函数中的this为指定对象
     强调：1.立刻执行，且只执行一次
	   2.执行时，临时替换时，执行后this回复原样
     如何：指定函数.call(替换this的对象,参数值,参数值...)
     call vs apply：参数值列表不同
      call：要求传入函数的参数列表,需要一个一个传进去
      apply：建立一个数组，将参数列表放进去，然后直接传数组
   2.bind()
    什么是：创建一个和函数完全相同的函数，并永久绑定函数中的this为指定对象
    如何： var 新函数=原函数.bind(替换this的对象,参数值,...)
      基于原函数，创建一个新函数，并绑定this为指定对象
 4.数组API
  //indexOf
   判断：
    every():判断数组中是否所有元素都符合要求
    some():判断数组中是否包含符合条件的元素
    如何：
     var bool=arr.every(function(elem,i,arr){
	//elem:当前元素值
	//i:当前位置
	//arr:当前数组对象
	return 判断条件
     })
    运行过程：every会拿着回调函数在每个元素上执行一次，只要碰到不满足条件的，就退出，并返回false，如果走到头了，就返回true
   遍历API：
    forEach():对原数组中每个元素，执行相同操作
    map():取出原数组中的元素值，执行相同操作后，放入新数组中返回，原数组保持不变
     如何：
      arr.forEach(function(elem,i,arr){
	 arr[i]=新值
      })
      var newArr=arr.map(function(elem,i,arr){
	 return 新值
      })
   过滤和汇总
    过滤：选取出原数组中符合条件的元素，组成新数组，原数组保持不变
     如何：var sub=arr.filter(function(elem,i,arr){
		return 判断条件	
	   })
	只有符合条件的元素，才会放到sub中
    汇总：将数组中每个元素值，汇总计算出一个结果
     如何：var result=arr.reduce(function(prev,elem,i,arr){
		//prev 截止目前累加值
		return prev+elem
     },base)
2.ES6
 核心：不改变原理的基础上，尽量简化开发
 1.let：声明提前，块级作用域
  什么是：代替var，用于声明变量
   为什么：var有2个问题：声明提前，没有块级作用域
   要求：
    1.不会被声明提前：
      检查，不允许提前使用未声明的变量
    2.添加块级作用域
     什么是块级作用域：if, while, do while, for 都是一级作用域
     为什么：避免块内的变量影响外部
     let声明的变量，只在当前块内有效
   原理：其实是匿名函数自调！
     let+for 实现闭包的效果
     强调：原来块内外都可使用的变量，出了块，就不能用了
 2.参数增强：
  1.默认值：定义函数时，可提前为部分参数变量指定默认值
    如何：function fun(参数1,参数2,...,参数n=默认值)
    强调：有默认值的参数必须放在参数列表的结尾
  2.剩余参数：代替arguments
    arguments的问题：2个
      1.不是数组
      2.必须完整获得所有参数
    如何：定义时：function fun(参数1,参数2,...,...数组名)
       意思是：除了前边明确的几个参数外，剩余的参数都放在数组中
      优点：1.是纯正的数组类型
	    2.可随意选择开始获取参数值的位置
  3.散播
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2018/2/28
ES6
 1.参数增强
  1.默认值 default：定义函数时，可提前为部分参数变量指定默认值
  2.剩余参数 rest：代替arguments
  3.散播 spread:将一个数组打散后，分别传入函数中
   何时：如果一个函数需要多个参数，而给定的值却来自一个数组时
   如何：fun(...数组)
   原理：fun.apply(null,数组)
 2.箭头函数：简化一切回调函数/匿名函数自调
  如何：3句话
   1.所有匿名函数（回调/自调）都可去function，改为=>
   2.如果参数只有一个，可省略()
   3.如果函数体只有一句话，可省略{}
      如果仅有的一句话还是return，可省略return
  特点：内外共用一个this
   如果不希望内外this通用，就不应用箭头函数简化
 3.模板字符串：代替+拼接字符串
   什么是：为动态生成打断内容，而提前定义的字符串模板
   何时：只要需要拼接都用模板字符串
   如何：
     1.用反引号``包裹字符串模板
      优点：支持换行，且不会和""或''冲突
     2.如果动态生成的内容/js表达式，必须用${}包裹
 4.解构：
  什么是：将一个对象/数组，拆散到多个变量中
  何时：只要在一个大的对象/数组中选取部分属性/元素放入变量中使用时
  如何：3种
   1.数组解构：下标对下标
    var date=[2018,2,28];
    var [y,m,d]=date;
    得到y=2018,m=2,d=28
   2.对象解构：属性对属性
    var dbconfig={
	ip:"xxx",
	port:"xxx",
	db:"xxx",
	user:"root",
	pwd:"123456"
    }
    var {ip:ip,user:user,pwd:pwd}=dbconfig;
   3.参数解构：属性对属性
    问题：传统参数定义是固定个数，固定先后顺序，无法灵活选择要传入的参数和不要传入的参数
     定义函数时：function fun(ip,port,db,user,pwd)
    解决
     定义函数时：function fun({ip:ip,port:port,db:db,user:user,pwd:pwd})
     简化为：function fun({ip,port,db,user,pwd})
     调用时：fun({属性名：值})   //不限制位置与个数
 5.for...of：简化for循环
  如何：for(var p of products){
	  p 会依次取出products中的每个商品
	}
 6.class:代替传统的封装，继承，多态的语法
  封装：
   1.对象直接量：
    var obj={
	属性名：变量名，如果属性名和变量名相同，可只写一个
		方法名(){...this.属性名}
    }
   2.创建一个类型
    class Student{
     //一个类型由2个部分组成
      //1.构造函数，定义属性结构，创建子对象
	constructor(sname,sage){
		this.sname=sname;
		this.sage=sage
	}
      //2.原型对象，保存子对象共有的API
       intr(){
	...
       }
    }
  继承：
   class Father{
	...
   }
   class Child extends Father{
	constructor(参数列表){
		super(参数列表)
	}
   }
  静态方法:
   calss xxx{
	static 方法名(){}
   }
  访问器属性：
   calss xxx{
	constructor(){
	 Object.defineProperties(this,{
	    _age:{
		writable:true,
                enumerable:false,
	    }
	 })
	 this.age=age
	}
	//保存在prototype中
	get age(){return this._age}
	set age(val){
	   if(val 符合要求)
	    this._age=val
	   else 报错
	}
   }
   使用方法完全一样
 7.promise：代替异步调用中的回调函数
    异步调用的回调函数的问题：回调地狱
     回调地狱的根本原因：过早的将下一个函数提前交给上一个函数
    为什么使用promise：避免回调地狱
    何时：只要多个异步调用必须先后执行时，就用promise
    如何：2步
      1.定义函数时：
       function prev(){
	return new Promise(function(open){
		//封装原来任务代码
		//决定何时打开开关
	})
       }
      2.调用时：
       prev().then(next)
       next一定会等待prev执行完，再执行
 补充：重构函数，先找到多个函数间相同部分，变量通过参数传递进去，前提：需要先知道相同部分